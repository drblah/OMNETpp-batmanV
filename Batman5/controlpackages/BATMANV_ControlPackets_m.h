//
// Generated file, do not edit! Created by nedtool 5.6 from inet/Batman5/controlpackages/BATMANV_ControlPackets.msg.
//

#ifndef __INET_BATMANV_CONTROLPACKETS_M_H
#define __INET_BATMANV_CONTROLPACKETS_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif

// cplusplus {{
#include "inet/common/INETDefs.h"
#include "inet/common/geometry/common/Coord.h"
#include "inet/linklayer/common/MACAddress.h"
#include "inet/Batman5/Batman5Files/batadv_definitions.h"

#define BIT0  0000000000000001
#define BIT1  0000000000000010
#define BIT2  0000000000000100
#define BIT3  0000000000001000
#define BIT4  0000000000010000
#define BIT5  0000000000100000
#define BIT6  0000000001000000
#define BIT7  0000000010000000
#define BIT8  0000000100000000
#define BIT9  0000001000000000
#define BIT10 0000010000000000
#define BIT11 0000100000000000
#define BIT12 0001000000000000
#define BIT13 0010000000000000
#define BIT14 0100000000000000
#define BIT15 1000000000000000

#define BATADV_COMPAT_VERSION 15
#define BATADV_TT_DATA_TYPE_MASK 0x0F
#define BATADV_OGM_HLEN 19
#define BATADV_OGM2_HLEN 20
#define BATADV_ELP_HLEN 16
#define BATADV_RR_LEN 16

#define BATADV_UNICAST_HLEN 10
#define BATADV_UNICAST_4ADDR_HLEN 18
#define BATADV_BCAST_HLEN 14
#define BATADV_CODED_HLEN 46
// }}


namespace inet {

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:64</tt> by nedtool.
 * <pre>
 * enum batadv_packettype
 * {
 *     // 0x00 - 0x3f: local packets or special rules for handling   
 *     BATADV_IV_OGM = 0x00;
 *     BATADV_BCAST = 0x01;
 *     BATADV_CODED = 0x02;
 *     BATADV_ELP = 0x03;	// BATMAN V
 *     BATADV_OGM2 = 0x04;	// BATMAN V
 *     // 0x40 - 0x7f: unicast   
 *     // 		BATADV_UNICAST_MIN     	  0x40;
 *     BATADV_UNICAST = 0x40;
 *     BATADV_UNICAST_FRAG = 0x41;
 *     BATADV_UNICAST_4ADDR = 0x42;
 *     BATADV_ICMP = 0x43;	// not implemented here
 *     BATADV_UNICAST_TVLV = 0x44;
 * 	// 		BATADV_UNICAST_MAX   	  0x7f;
 * 	// 0x80 - 0xff: reserved   
 * }
 * </pre>
 */
enum batadv_packettype {
    BATADV_IV_OGM = 0x00,
    BATADV_BCAST = 0x01,
    BATADV_CODED = 0x02,
    BATADV_ELP = 0x03,
    BATADV_OGM2 = 0x04,
    BATADV_UNICAST = 0x40,
    BATADV_UNICAST_FRAG = 0x41,
    BATADV_UNICAST_4ADDR = 0x42,
    BATADV_ICMP = 0x43,
    BATADV_UNICAST_TVLV = 0x44
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:82</tt> by nedtool.
 * <pre>
 * enum batadv_version
 * {
 *     BATMAN_IV = 4;
 *     BATMAN_V = 5;
 * }
 * </pre>
 */
enum batadv_version {
    BATMAN_IV = 4,
    BATMAN_V = 5
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:88</tt> by nedtool.
 * <pre>
 * //	enum batadv_subtype - packet subtype for unicast4addr
 * enum batadv_subtype
 * {
 *     BATADV_P_DATA = 0x01;	//	user payload
 *     BATADV_P_DAT_DHT_GET = 0x02;	//	DHT request message
 *     BATADV_P_DAT_DHT_PUT = 0x03;	//	DHT store message
 *     BATADV_P_DAT_CACHE_REPLY = 0x04;	//	ARP reply generated by DAT
 * }
 * </pre>
 */
enum batadv_subtype {
    BATADV_P_DATA = 0x01,
    BATADV_P_DAT_DHT_GET = 0x02,
    BATADV_P_DAT_DHT_PUT = 0x03,
    BATADV_P_DAT_CACHE_REPLY = 0x04
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:96</tt> by nedtool.
 * <pre>
 * //	enum batadv_iv_flags - flags used in B.A.T.M.A.N. IV OGM packets
 * enum batadv_iv_flags
 * {
 *     BATADV_NOT_BEST_NEXT_HOP = BIT0;	//	flag is set when ogm packet is forwarded and was previously received from someone else than the best neighbor
 *     BATADV_PRIMARIES_FIRST_HOP = BIT1;	//	flag unused
 *     BATADV_DIRECTLINK = BIT2;	//	flag is for the first hop or if rebroadcasted from a one hop neighbor on the interface where it was originally received
 * }
 * </pre>
 */
enum batadv_iv_flags {
    BATADV_NOT_BEST_NEXT_HOP = BIT0,
    BATADV_PRIMARIES_FIRST_HOP = BIT1,
    BATADV_DIRECTLINK = BIT2
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:103</tt> by nedtool.
 * <pre>
 * //	enum batadv_icmp_packettype - ICMP message types
 * enum batadv_icmp_messagetype
 * {
 *     BATADV_ECHO_REPLY = 0;		//	success reply to BATADV_ECHO_REQUEST
 *     BATADV_DESTINATION_UNREACHABLE = 3;		//	failure when route to destination not found
 *     BATADV_ECHO_REQUEST = 8;		//	request BATADV_ECHO_REPLY from destination
 *     BATADV_TTL_EXCEEDED = 11;	//	error after BATADV_ECHO_REQUEST traversed too many hops
 *     BATADV_PARAMETER_PROBLEM = 12;	//	return code for malformed messages
 *     BATADV_TP = 15;	//	throughput meter packet
 * }
 * </pre>
 */
enum batadv_icmp_messagetype {
    BATADV_ECHO_REPLY = 0,
    BATADV_DESTINATION_UNREACHABLE = 3,
    BATADV_ECHO_REQUEST = 8,
    BATADV_TTL_EXCEEDED = 11,
    BATADV_PARAMETER_PROBLEM = 12,
    BATADV_TP = 15
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:114</tt> by nedtool.
 * <pre>
 * // enum batadv_icmp_tp_subtype - ICMP TP Meter packet subtypes
 * enum batadv_icmp_tp_subtype
 * {
 *     BATADV_TP_MSG = 0;	// \@BATADV_TP_MSG: Msg from sender to receiver
 *     BATADV_TP_ACK = 1;	// \@BATADV_TP_ACK: acknowledgment from receiver to sender
 * }
 * </pre>
 */
enum batadv_icmp_tp_subtype {
    BATADV_TP_MSG = 0,
    BATADV_TP_ACK = 1
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:120</tt> by nedtool.
 * <pre>
 * //	batadv_mcast_flags - flags for multicast capabilities and settings
 * enum batadv_mcast_flags
 * {
 *     BATADV_MCAST_WANT_ALL_UNSNOOPABLES = BIT0; 	//	we want all packets destined for 224.0.0.0/24 or ff02::1
 *     BATADV_MCAST_WANT_ALL_IPV4 = BIT1; 	//	we want all IPv4 multicast packets
 *     BATADV_MCAST_WANT_ALL_IPV6 = BIT2;		//	we want all IPv6 multicast packets
 * }
 * </pre>
 */
enum batadv_mcast_flags {
    BATADV_MCAST_WANT_ALL_UNSNOOPABLES = BIT0,
    BATADV_MCAST_WANT_ALL_IPV4 = BIT1,
    BATADV_MCAST_WANT_ALL_IPV6 = BIT2
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:127</tt> by nedtool.
 * <pre>
 * //	enum batadv_tt_data_flags - flags for tt data tvlv
 * enum batadv_tt_data_flags
 * {
 *     BATADV_TT_OGM_DIFF = BIT0;		//	TT diff propagated through OGM
 *     BATADV_TT_REQUEST = BIT1;		//	TT request message
 *     BATADV_TT_RESPONSE = BIT2;		//	TT response message
 *     BATADV_TT_FULL_TABLE = BIT4;		//	contains full table to replace existing table
 * }
 * </pre>
 */
enum batadv_tt_data_flags {
    BATADV_TT_OGM_DIFF = BIT0,
    BATADV_TT_REQUEST = BIT1,
    BATADV_TT_RESPONSE = BIT2,
    BATADV_TT_FULL_TABLE = BIT4
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:135</tt> by nedtool.
 * <pre>
 * //	enum batadv_vlan_flags - flags for the four MSB of any vlan ID field
 * enum batadv_vlan_flags
 * {
 *     BATADV_VLAN_HAS_TAG = BIT14;	//	whether the field contains a valid vlan tag or not
 * }
 * </pre>
 */
enum batadv_vlan_flags {
    BATADV_VLAN_HAS_TAG = BIT14
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:140</tt> by nedtool.
 * <pre>
 * //	enum batadv_bla_claimframe - claim frame types for the bridge loop avoidance
 * enum batadv_bla_claimframe
 * {
 *     BATADV_CLAIM_TYPE_CLAIM = 0x00;	//	claim of a client mac address
 *     BATADV_CLAIM_TYPE_UNCLAIM = 0x01;	//	unclaim of a client mac address
 *     BATADV_CLAIM_TYPE_ANNOUNCE = 0x02;	//	announcement of backbone with current crc
 *     BATADV_CLAIM_TYPE_REQUEST = 0x03;	//	request of full claim table
 *     BATADV_CLAIM_TYPE_LOOPDETECT = 0x04;	//	mesh-traversing loop detect packet
 * }
 * </pre>
 */
enum batadv_bla_claimframe {
    BATADV_CLAIM_TYPE_CLAIM = 0x00,
    BATADV_CLAIM_TYPE_UNCLAIM = 0x01,
    BATADV_CLAIM_TYPE_ANNOUNCE = 0x02,
    BATADV_CLAIM_TYPE_REQUEST = 0x03,
    BATADV_CLAIM_TYPE_LOOPDETECT = 0x04
};

/**
 * Enum generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:149</tt> by nedtool.
 * <pre>
 * //	enum batadv_tvlv_type - tvlv type definitions
 * enum batadv_tvlv_type
 * {
 *     BATADV_TVLV_GW = 0x01;	//	gateway tvlv
 *     BATADV_TVLV_DAT = 0x02;	//	distributed arp table tvlv
 *     BATADV_TVLV_NC = 0x03;	//	network coding tvlv
 *     BATADV_TVLV_TT = 0x04;	//	translation table tvlv
 *     BATADV_TVLV_ROAM = 0x05;	//	roaming advertisement tvlv
 *     BATADV_TVLV_MCAST = 0x06;	//	multicast capability tvlv
 * }
 * </pre>
 */
enum batadv_tvlv_type {
    BATADV_TVLV_GW = 0x01,
    BATADV_TVLV_DAT = 0x02,
    BATADV_TVLV_NC = 0x03,
    BATADV_TVLV_TT = 0x04,
    BATADV_TVLV_ROAM = 0x05,
    BATADV_TVLV_MCAST = 0x06
};

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:159</tt> by nedtool.
 * <pre>
 * // Base packet for BATMAN V Control Packets
 * packet BATMANV_ControlPackets
 * {
 *     uint8_t batadv_packettype;
 *     uint8_t batadv_version;
 * }
 * </pre>
 */
class INET_API BATMANV_ControlPackets : public ::omnetpp::cPacket
{
  protected:
    uint8_t batadv_packettype;
    uint8_t batadv_version;

  private:
    void copy(const BATMANV_ControlPackets& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BATMANV_ControlPackets&);

  public:
    BATMANV_ControlPackets(const char *name=nullptr, short kind=0);
    BATMANV_ControlPackets(const BATMANV_ControlPackets& other);
    virtual ~BATMANV_ControlPackets();
    BATMANV_ControlPackets& operator=(const BATMANV_ControlPackets& other);
    virtual BATMANV_ControlPackets *dup() const override {return new BATMANV_ControlPackets(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getBatadv_packettype() const;
    virtual void setBatadv_packettype(uint8_t batadv_packettype);
    virtual uint8_t getBatadv_version() const;
    virtual void setBatadv_version(uint8_t batadv_version);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BATMANV_ControlPackets& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BATMANV_ControlPackets& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:166</tt> by nedtool.
 * <pre>
 * // Base packet for BATMAN V TVLV Packets
 * packet BATMANV_TVLVPackets
 * {
 *     uint8_t batadv_tvlv_type;
 *     uint8_t version;
 *     uint16_t length;
 * }
 * </pre>
 */
class INET_API BATMANV_TVLVPackets : public ::omnetpp::cPacket
{
  protected:
    uint8_t batadv_tvlv_type;
    uint8_t version;
    uint16_t length;

  private:
    void copy(const BATMANV_TVLVPackets& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BATMANV_TVLVPackets&);

  public:
    BATMANV_TVLVPackets(const char *name=nullptr, short kind=0);
    BATMANV_TVLVPackets(const BATMANV_TVLVPackets& other);
    virtual ~BATMANV_TVLVPackets();
    BATMANV_TVLVPackets& operator=(const BATMANV_TVLVPackets& other);
    virtual BATMANV_TVLVPackets *dup() const override {return new BATMANV_TVLVPackets(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getBatadv_tvlv_type() const;
    virtual void setBatadv_tvlv_type(uint8_t batadv_tvlv_type);
    virtual uint8_t getVersion() const;
    virtual void setVersion(uint8_t version);
    virtual uint16_t getLength() const;
    virtual void setLength(uint16_t length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BATMANV_TVLVPackets& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BATMANV_TVLVPackets& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:175</tt> by nedtool.
 * <pre>
 * //gateway data propagated through gw tvlv container
 * packet batadv_tvlv_gateway_data extends BATMANV_TVLVPackets
 * {
 *     batadv_tvlv_type = BATADV_TVLV_GW;
 *     version = BATADV_COMPAT_VERSION;
 *     length = 8;
 *     uint32_t bandwidth_down;
 *     uint32_t bandwidth_up;
 *     byteLength = 12;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_gateway_data : public ::inet::BATMANV_TVLVPackets
{
  protected:
    uint32_t bandwidth_down;
    uint32_t bandwidth_up;

  private:
    void copy(const batadv_tvlv_gateway_data& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_gateway_data&);

  public:
    batadv_tvlv_gateway_data(const char *name=nullptr, short kind=0);
    batadv_tvlv_gateway_data(const batadv_tvlv_gateway_data& other);
    virtual ~batadv_tvlv_gateway_data();
    batadv_tvlv_gateway_data& operator=(const batadv_tvlv_gateway_data& other);
    virtual batadv_tvlv_gateway_data *dup() const override {return new batadv_tvlv_gateway_data(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getBandwidth_down() const;
    virtual void setBandwidth_down(uint32_t bandwidth_down);
    virtual uint32_t getBandwidth_up() const;
    virtual void setBandwidth_up(uint32_t bandwidth_up);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_gateway_data& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_gateway_data& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:185</tt> by nedtool.
 * <pre>
 * // DAT: boolean telling that this node caches ARP requests / replies for the mesh
 * packet batadv_tvlv_dat extends BATMANV_TVLVPackets
 * {
 *     batadv_tvlv_type = BATADV_TVLV_DAT;
 *     version = BATADV_COMPAT_VERSION;
 *     length = 0;
 *     byteLength = 4;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_dat : public ::inet::BATMANV_TVLVPackets
{
  protected:

  private:
    void copy(const batadv_tvlv_dat& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_dat&);

  public:
    batadv_tvlv_dat(const char *name=nullptr, short kind=0);
    batadv_tvlv_dat(const batadv_tvlv_dat& other);
    virtual ~batadv_tvlv_dat();
    batadv_tvlv_dat& operator=(const batadv_tvlv_dat& other);
    virtual batadv_tvlv_dat *dup() const override {return new batadv_tvlv_dat(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_dat& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_dat& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:193</tt> by nedtool.
 * <pre>
 * // Network Coding: boolean telling that this node knows how to decode nc-packets
 * packet batadv_tvlv_nc extends BATMANV_TVLVPackets
 * {
 *     batadv_tvlv_type = BATADV_TVLV_NC;
 *     version = BATADV_COMPAT_VERSION;
 *     length = 0;
 *     byteLength = 4;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_nc : public ::inet::BATMANV_TVLVPackets
{
  protected:

  private:
    void copy(const batadv_tvlv_nc& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_nc&);

  public:
    batadv_tvlv_nc(const char *name=nullptr, short kind=0);
    batadv_tvlv_nc(const batadv_tvlv_nc& other);
    virtual ~batadv_tvlv_nc();
    batadv_tvlv_nc& operator=(const batadv_tvlv_nc& other);
    virtual batadv_tvlv_nc *dup() const override {return new batadv_tvlv_nc(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_nc& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_nc& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:201</tt> by nedtool.
 * <pre>
 * //tt data propagated through the tt tvlv container
 * packet batadv_tvlv_tt_data extends BATMANV_TVLVPackets
 * {
 *     batadv_tvlv_type = BATADV_TVLV_TT;
 *     version = BATADV_COMPAT_VERSION;
 *     length = 4;
 *     uint8_t tt_flags;
 *     uint8_t ttvn;
 *     uint16_t num_vlan = 0;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_tt_data : public ::inet::BATMANV_TVLVPackets
{
  protected:
    uint8_t tt_flags;
    uint8_t ttvn;
    uint16_t num_vlan;

  private:
    void copy(const batadv_tvlv_tt_data& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_tt_data&);

  public:
    batadv_tvlv_tt_data(const char *name=nullptr, short kind=0);
    batadv_tvlv_tt_data(const batadv_tvlv_tt_data& other);
    virtual ~batadv_tvlv_tt_data();
    batadv_tvlv_tt_data& operator=(const batadv_tvlv_tt_data& other);
    virtual batadv_tvlv_tt_data *dup() const override {return new batadv_tvlv_tt_data(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTt_flags() const;
    virtual void setTt_flags(uint8_t tt_flags);
    virtual uint8_t getTtvn() const;
    virtual void setTtvn(uint8_t ttvn);
    virtual uint16_t getNum_vlan() const;
    virtual void setNum_vlan(uint16_t num_vlan);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_tt_data& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_tt_data& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:210</tt> by nedtool.
 * <pre>
 * packet batadv_tvlv_tt_vlan extends batadv_tvlv_tt_data
 * {
 *     num_vlan = 1;
 *     int32_t crc32;
 *     int16_t vid_vlan;
 *     int16_t reserved_vlan;
 *     byteLength = 16;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_tt_vlan : public ::inet::batadv_tvlv_tt_data
{
  protected:
    int32_t crc32;
    int16_t vid_vlan;
    int16_t reserved_vlan;

  private:
    void copy(const batadv_tvlv_tt_vlan& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_tt_vlan&);

  public:
    batadv_tvlv_tt_vlan(const char *name=nullptr, short kind=0);
    batadv_tvlv_tt_vlan(const batadv_tvlv_tt_vlan& other);
    virtual ~batadv_tvlv_tt_vlan();
    batadv_tvlv_tt_vlan& operator=(const batadv_tvlv_tt_vlan& other);
    virtual batadv_tvlv_tt_vlan *dup() const override {return new batadv_tvlv_tt_vlan(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int32_t getCrc32() const;
    virtual void setCrc32(int32_t crc32);
    virtual int16_t getVid_vlan() const;
    virtual void setVid_vlan(int16_t vid_vlan);
    virtual int16_t getReserved_vlan() const;
    virtual void setReserved_vlan(int16_t reserved_vlan);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_tt_vlan& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_tt_vlan& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:219</tt> by nedtool.
 * <pre>
 * // 
 * packet batadv_tvlv_tt_change extends batadv_tvlv_tt_data
 * {
 *     int8_t flags_change;// enum batadv_tt_client_flags - TT client specific flags
 *     int16_t reserved16_change;
 *     int8_t reserved8_change;
 *     MACAddress addr;
 *     int16_t vid_change;
 *     byteLength = 20;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_tt_change : public ::inet::batadv_tvlv_tt_data
{
  protected:
    int8_t flags_change;
    int16_t reserved16_change;
    int8_t reserved8_change;
    MACAddress addr;
    int16_t vid_change;

  private:
    void copy(const batadv_tvlv_tt_change& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_tt_change&);

  public:
    batadv_tvlv_tt_change(const char *name=nullptr, short kind=0);
    batadv_tvlv_tt_change(const batadv_tvlv_tt_change& other);
    virtual ~batadv_tvlv_tt_change();
    batadv_tvlv_tt_change& operator=(const batadv_tvlv_tt_change& other);
    virtual batadv_tvlv_tt_change *dup() const override {return new batadv_tvlv_tt_change(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int8_t getFlags_change() const;
    virtual void setFlags_change(int8_t flags_change);
    virtual int16_t getReserved16_change() const;
    virtual void setReserved16_change(int16_t reserved16_change);
    virtual int8_t getReserved8_change() const;
    virtual void setReserved8_change(int8_t reserved8_change);
    virtual MACAddress& getAddr();
    virtual const MACAddress& getAddr() const {return const_cast<batadv_tvlv_tt_change*>(this)->getAddr();}
    virtual void setAddr(const MACAddress& addr);
    virtual int16_t getVid_change() const;
    virtual void setVid_change(int16_t vid_change);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_tt_change& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_tt_change& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:228</tt> by nedtool.
 * <pre>
 * packet batadv_tvlv_tt_vlan_change extends batadv_tvlv_tt_data
 * {
 *     num_vlan = 1;
 *     int32_t crc32;
 *     int16_t vid_vlan;
 *     int16_t reserved_vlan;
 * 
 *     int8_t flags;// enum batadv_tt_client_flags - TT client specific flags
 *     int16_t reserved16_change;
 *     int8_t reserved8_change;
 *     MACAddress addr;
 *     int16_t vid_change;
 *     byteLength = 28;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_tt_vlan_change : public ::inet::batadv_tvlv_tt_data
{
  protected:
    int32_t crc32;
    int16_t vid_vlan;
    int16_t reserved_vlan;
    int8_t flags;
    int16_t reserved16_change;
    int8_t reserved8_change;
    MACAddress addr;
    int16_t vid_change;

  private:
    void copy(const batadv_tvlv_tt_vlan_change& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_tt_vlan_change&);

  public:
    batadv_tvlv_tt_vlan_change(const char *name=nullptr, short kind=0);
    batadv_tvlv_tt_vlan_change(const batadv_tvlv_tt_vlan_change& other);
    virtual ~batadv_tvlv_tt_vlan_change();
    batadv_tvlv_tt_vlan_change& operator=(const batadv_tvlv_tt_vlan_change& other);
    virtual batadv_tvlv_tt_vlan_change *dup() const override {return new batadv_tvlv_tt_vlan_change(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int32_t getCrc32() const;
    virtual void setCrc32(int32_t crc32);
    virtual int16_t getVid_vlan() const;
    virtual void setVid_vlan(int16_t vid_vlan);
    virtual int16_t getReserved_vlan() const;
    virtual void setReserved_vlan(int16_t reserved_vlan);
    virtual int8_t getFlags() const;
    virtual void setFlags(int8_t flags);
    virtual int16_t getReserved16_change() const;
    virtual void setReserved16_change(int16_t reserved16_change);
    virtual int8_t getReserved8_change() const;
    virtual void setReserved8_change(int8_t reserved8_change);
    virtual MACAddress& getAddr();
    virtual const MACAddress& getAddr() const {return const_cast<batadv_tvlv_tt_vlan_change*>(this)->getAddr();}
    virtual void setAddr(const MACAddress& addr);
    virtual int16_t getVid_change() const;
    virtual void setVid_change(int16_t vid_change);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_tt_vlan_change& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_tt_vlan_change& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:243</tt> by nedtool.
 * <pre>
 * // Inform the old AP about the new location of the non-mesh client
 * packet batadv_tvlv_roam_adv extends BATMANV_TVLVPackets
 * {
 *     batadv_tvlv_type = BATADV_TVLV_ROAM;
 *     version = BATADV_COMPAT_VERSION;
 *     length = 8;
 *     MACAddress client;
 *     uint16_t vid;
 *     byteLength = 12;
 * }
 * </pre>
 */
class INET_API batadv_tvlv_roam_adv : public ::inet::BATMANV_TVLVPackets
{
  protected:
    MACAddress client;
    uint16_t vid;

  private:
    void copy(const batadv_tvlv_roam_adv& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_roam_adv&);

  public:
    batadv_tvlv_roam_adv(const char *name=nullptr, short kind=0);
    batadv_tvlv_roam_adv(const batadv_tvlv_roam_adv& other);
    virtual ~batadv_tvlv_roam_adv();
    batadv_tvlv_roam_adv& operator=(const batadv_tvlv_roam_adv& other);
    virtual batadv_tvlv_roam_adv *dup() const override {return new batadv_tvlv_roam_adv(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual MACAddress& getClient();
    virtual const MACAddress& getClient() const {return const_cast<batadv_tvlv_roam_adv*>(this)->getClient();}
    virtual void setClient(const MACAddress& client);
    virtual uint16_t getVid() const;
    virtual void setVid(uint16_t vid);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_roam_adv& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_roam_adv& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:252</tt> by nedtool.
 * <pre>
 * packet batadv_tvlv_mcast extends BATMANV_TVLVPackets
 * {
 *     batadv_tvlv_type = BATADV_TVLV_MCAST;
 *     version = BATADV_COMPAT_VERSION;
 *     length = 4;
 *     int8_t flags;
 *     int16_t reserved16;
 *     int8_t reserved8;
 *     byteLength = 8;
 * }
 * 
 * //
 * //	*****************************	Packet-Definitions	*****************************
 * //
 * </pre>
 */
class INET_API batadv_tvlv_mcast : public ::inet::BATMANV_TVLVPackets
{
  protected:
    int8_t flags;
    int16_t reserved16;
    int8_t reserved8;

  private:
    void copy(const batadv_tvlv_mcast& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_tvlv_mcast&);

  public:
    batadv_tvlv_mcast(const char *name=nullptr, short kind=0);
    batadv_tvlv_mcast(const batadv_tvlv_mcast& other);
    virtual ~batadv_tvlv_mcast();
    batadv_tvlv_mcast& operator=(const batadv_tvlv_mcast& other);
    virtual batadv_tvlv_mcast *dup() const override {return new batadv_tvlv_mcast(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int8_t getFlags() const;
    virtual void setFlags(int8_t flags);
    virtual int16_t getReserved16() const;
    virtual void setReserved16(int16_t reserved16);
    virtual int8_t getReserved8() const;
    virtual void setReserved8(int8_t reserved8);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_tvlv_mcast& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_tvlv_mcast& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:268</tt> by nedtool.
 * <pre>
 * // Represents Echo Location Protocol packets
 * class batadv_elp_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_ELP;			//	batman-adv packet type, part of the general header ELP-Packet = 0x03
 *     batadv_version = BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the genereal header
 *     MACAddress orig;					//	originator mac address
 *     uint32_t seqno;					//	sequence number
 *     uint32_t elp_interval;			//	currently used ELP sending interval in ms
 *     double x;						// 	only used in position based metrics, packet-size will be adapted if used
 *     double y;						// 	only used in position based metrics, packet-size will be adapted if used
 *     double z;						// 	only used in position based metrics, packet-size will be adapted if used
 *     byteLength = sizeof(batadv_packettype) + sizeof(batadv_version) + orig.getAddressSize() + sizeof(seqno) + sizeof(elp_interval);
 *     						//1+1+6+4+4;
 * }
 * </pre>
 */
class INET_API batadv_elp_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    MACAddress orig;
    uint32_t seqno;
    uint32_t elp_interval;
    double x;
    double y;
    double z;

  private:
    void copy(const batadv_elp_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_elp_packet&);

  public:
    batadv_elp_packet(const char *name=nullptr);
    batadv_elp_packet(const batadv_elp_packet& other);
    virtual ~batadv_elp_packet();
    batadv_elp_packet& operator=(const batadv_elp_packet& other);
    virtual batadv_elp_packet *dup() const override {return new batadv_elp_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual MACAddress& getOrig();
    virtual const MACAddress& getOrig() const {return const_cast<batadv_elp_packet*>(this)->getOrig();}
    virtual void setOrig(const MACAddress& orig);
    virtual uint32_t getSeqno() const;
    virtual void setSeqno(uint32_t seqno);
    virtual uint32_t getElp_interval() const;
    virtual void setElp_interval(uint32_t elp_interval);
    virtual double getX() const;
    virtual void setX(double x);
    virtual double getY() const;
    virtual void setY(double y);
    virtual double getZ() const;
    virtual void setZ(double z);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_elp_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_elp_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:281</tt> by nedtool.
 * <pre>
 * class batadv_elpProbe_packet extends batadv_elp_packet
 * {
 *     batadv_elp_packet elp_packet;
 *     byteLength = BATADV_ELP_MIN_PROBE_SIZE;
 * }
 * </pre>
 */
class INET_API batadv_elpProbe_packet : public ::inet::batadv_elp_packet
{
  protected:
    batadv_elp_packet elp_packet;

  private:
    void copy(const batadv_elpProbe_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_elpProbe_packet&);

  public:
    batadv_elpProbe_packet(const char *name=nullptr);
    batadv_elpProbe_packet(const batadv_elpProbe_packet& other);
    virtual ~batadv_elpProbe_packet();
    batadv_elpProbe_packet& operator=(const batadv_elpProbe_packet& other);
    virtual batadv_elpProbe_packet *dup() const override {return new batadv_elpProbe_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual batadv_elp_packet& getElp_packet();
    virtual const batadv_elp_packet& getElp_packet() const {return const_cast<batadv_elpProbe_packet*>(this)->getElp_packet();}
    virtual void setElp_packet(const batadv_elp_packet& elp_packet);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_elpProbe_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_elpProbe_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:287</tt> by nedtool.
 * <pre>
 * // Represents Originator Message packets
 * class batadv_iv_ogm_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_IV_OGM;	//	batman-adv packet type, part of the general header
 *     batadv_version = BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the genereal header
 *     uint8_t ttl;				//	time to live for this packet, part of the genereal header
 *     uint8_t flags;				//	contains routing relevant flags - see enum batadv_iv_flags
 *     uint32_t seqno;				//	sequence identification
 *     MACAddress orig;				//	address of the source node
 *     MACAddress prev_sender;		//	address of the previous sender
 *     uint8_t reserved;			//	reserved byte for alignment
 *     uint8_t tq;					//	transmission quality, between 0...255
 *     uint16_t tvlv_len;			//	length of tvlv data following the ogm header
 * }
 * </pre>
 */
class INET_API batadv_iv_ogm_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    uint8_t flags;
    uint32_t seqno;
    MACAddress orig;
    MACAddress prev_sender;
    uint8_t reserved;
    uint8_t tq;
    uint16_t tvlv_len;

  private:
    void copy(const batadv_iv_ogm_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_iv_ogm_packet&);

  public:
    batadv_iv_ogm_packet(const char *name=nullptr);
    batadv_iv_ogm_packet(const batadv_iv_ogm_packet& other);
    virtual ~batadv_iv_ogm_packet();
    batadv_iv_ogm_packet& operator=(const batadv_iv_ogm_packet& other);
    virtual batadv_iv_ogm_packet *dup() const override {return new batadv_iv_ogm_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual uint8_t getFlags() const;
    virtual void setFlags(uint8_t flags);
    virtual uint32_t getSeqno() const;
    virtual void setSeqno(uint32_t seqno);
    virtual MACAddress& getOrig();
    virtual const MACAddress& getOrig() const {return const_cast<batadv_iv_ogm_packet*>(this)->getOrig();}
    virtual void setOrig(const MACAddress& orig);
    virtual MACAddress& getPrev_sender();
    virtual const MACAddress& getPrev_sender() const {return const_cast<batadv_iv_ogm_packet*>(this)->getPrev_sender();}
    virtual void setPrev_sender(const MACAddress& prev_sender);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);
    virtual uint8_t getTq() const;
    virtual void setTq(uint8_t tq);
    virtual uint16_t getTvlv_len() const;
    virtual void setTvlv_len(uint16_t tvlv_len);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_iv_ogm_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_iv_ogm_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:301</tt> by nedtool.
 * <pre>
 * // Represents Originator Message Version 2 packets
 * class batadv_ogm2_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_OGM2;			//	batman-adv packet type, part of the general header, ogmv2-packet = 0x04
 *     batadv_version = BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the general header
 *     uint8_t ttl;					//	time to live for this packet, part of the general header
 *     uint8_t flags;					//	reseved for routing relevant flags - currently always 0
 *     uint32_t seqno;					//	sequence number
 *     MACAddress orig;					//	originator mac address
 *     uint16_t tvlv_len;				//	length of the appended tvlv buffer (in bytes)
 *     uint32_t metric;					//	the currently flooded path throughput
 *     MACAddress prev_sender;				//  For using NetworkCoding in BATMANV
 *     //    BATMANV_TVLVPackets tvlv_packet;
 *     byteLength = 20; // without tvlv;
 * }
 * 
 * //	All packet headers in front of an ethernet header have to be completely
 * //	divisible by 2 but not by 4 to make the payload after the ethernet
 * //	header again 4 bytes boundary aligned.
 * //	
 * //	A packing of 2 is necessary to avoid extra padding at the end of the struct
 * //	caused by a structure member which is larger than two bytes. Otherwise
 * //	the structure would not fulfill the previously mentioned rule to avoid the
 * //	misalignment of the payload after the ethernet header. It may also lead to
 * //	leakage of information when the padding it not initialized before sending.
 * </pre>
 */
class INET_API batadv_ogm2_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    uint8_t flags;
    uint32_t seqno;
    MACAddress orig;
    uint16_t tvlv_len;
    uint32_t metric;
    MACAddress prev_sender;

  private:
    void copy(const batadv_ogm2_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_ogm2_packet&);

  public:
    batadv_ogm2_packet(const char *name=nullptr);
    batadv_ogm2_packet(const batadv_ogm2_packet& other);
    virtual ~batadv_ogm2_packet();
    batadv_ogm2_packet& operator=(const batadv_ogm2_packet& other);
    virtual batadv_ogm2_packet *dup() const override {return new batadv_ogm2_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual uint8_t getFlags() const;
    virtual void setFlags(uint8_t flags);
    virtual uint32_t getSeqno() const;
    virtual void setSeqno(uint32_t seqno);
    virtual MACAddress& getOrig();
    virtual const MACAddress& getOrig() const {return const_cast<batadv_ogm2_packet*>(this)->getOrig();}
    virtual void setOrig(const MACAddress& orig);
    virtual uint16_t getTvlv_len() const;
    virtual void setTvlv_len(uint16_t tvlv_len);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual MACAddress& getPrev_sender();
    virtual const MACAddress& getPrev_sender() const {return const_cast<batadv_ogm2_packet*>(this)->getPrev_sender();}
    virtual void setPrev_sender(const MACAddress& prev_sender);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_ogm2_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_ogm2_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:326</tt> by nedtool.
 * <pre>
 * // Represents unicast packet for network payload
 * class batadv_unicast_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_UNICAST;	//	batman-adv packet type, part of the general header
 *     batadv_version = BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the genereal header
 *     uint8_t ttl;				//	time to live for this packet, part of the genereal header
 *     uint8_t ttvn; 				//	destination translation table version number
 *     MACAddress dest;				//	originator destination of the unicast packet
 *     MACAddress src;				//	address of the source
 *     MACAddress h_source;			//  used for network coding with BATMAN V
 *     MACAddress h_dest;				//  used for network coding with BATMAN V
 *     bool decoded;			//  used for network coding with BATMAN V
 *     uint64_t packet_id;			//  used for network coding with BATMAN V
 *     byteLength = BATADV_UNICAST_HLEN;
 * 	//	"4 bytes boundary + 2 bytes" long to make the payload after the following ethernet header again 4 bytes boundary aligned
 * }
 * </pre>
 */
class INET_API batadv_unicast_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    uint8_t ttvn;
    MACAddress dest;
    MACAddress src;
    MACAddress h_source;
    MACAddress h_dest;
    bool decoded;
    uint64_t packet_id;

  private:
    void copy(const batadv_unicast_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_unicast_packet&);

  public:
    batadv_unicast_packet(const char *name=nullptr);
    batadv_unicast_packet(const batadv_unicast_packet& other);
    virtual ~batadv_unicast_packet();
    batadv_unicast_packet& operator=(const batadv_unicast_packet& other);
    virtual batadv_unicast_packet *dup() const override {return new batadv_unicast_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual uint8_t getTtvn() const;
    virtual void setTtvn(uint8_t ttvn);
    virtual MACAddress& getDest();
    virtual const MACAddress& getDest() const {return const_cast<batadv_unicast_packet*>(this)->getDest();}
    virtual void setDest(const MACAddress& dest);
    virtual MACAddress& getSrc();
    virtual const MACAddress& getSrc() const {return const_cast<batadv_unicast_packet*>(this)->getSrc();}
    virtual void setSrc(const MACAddress& src);
    virtual MACAddress& getH_source();
    virtual const MACAddress& getH_source() const {return const_cast<batadv_unicast_packet*>(this)->getH_source();}
    virtual void setH_source(const MACAddress& h_source);
    virtual MACAddress& getH_dest();
    virtual const MACAddress& getH_dest() const {return const_cast<batadv_unicast_packet*>(this)->getH_dest();}
    virtual void setH_dest(const MACAddress& h_dest);
    virtual bool getDecoded() const;
    virtual void setDecoded(bool decoded);
    virtual uint64_t getPacket_id() const;
    virtual void setPacket_id(uint64_t packet_id);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_unicast_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_unicast_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:342</tt> by nedtool.
 * <pre>
 * // Represents extended unicast packet
 * class batadv_unicast_4addr_packet extends batadv_unicast_packet
 * {
 *     batadv_packettype = BATADV_UNICAST_4ADDR;	//	batman-adv packet type, part of the general header	
 *     uint8_t subtype;	//	packet subtype
 *     uint8_t reserved;	//	reserved byte for alignment
 *     byteLength = BATADV_UNICAST_4ADDR_HLEN;
 * 	//	"4 bytes boundary + 2 bytes" long to make the payload after the following ethernet header again 4 bytes boundary aligned
 * }
 * </pre>
 */
class INET_API batadv_unicast_4addr_packet : public ::inet::batadv_unicast_packet
{
  protected:
    uint8_t subtype;
    uint8_t reserved;

  private:
    void copy(const batadv_unicast_4addr_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_unicast_4addr_packet&);

  public:
    batadv_unicast_4addr_packet(const char *name=nullptr);
    batadv_unicast_4addr_packet(const batadv_unicast_4addr_packet& other);
    virtual ~batadv_unicast_4addr_packet();
    batadv_unicast_4addr_packet& operator=(const batadv_unicast_4addr_packet& other);
    virtual batadv_unicast_4addr_packet *dup() const override {return new batadv_unicast_4addr_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getSubtype() const;
    virtual void setSubtype(uint8_t subtype);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_unicast_4addr_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_unicast_4addr_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:351</tt> by nedtool.
 * <pre>
 * // Represents fragmented packet
 * class batadv_frag_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_UNICAST_FRAG;	//	batman-adv packet type, part of the general header
 *     batadv_version = BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
 *     uint8_t ttl;						//	time to live for this packet, part of the genereal header
 *     // #if defined(__BIG_ENDIAN_BITFIELD)
 *     //uint8_t   	no:4;						//	fragment number within this sequence
 *     //uint8_t   	priority:3;					//	priority of frame, from ToS IP precedence or 802.1p
 *     //uint8_t   	reserved:1;					//	reserved byte for alignment
 *     // #elif defined(__LITTLE_ENDIAN_BITFIELD)
 *     //uint8_t   	reserved:1;
 *     //uint8_t  	priority:3;
 *     //uint8_t   	no:4;
 *     // #else
 *     // #error "unknown bitfield endianness"
 *     // #endif
 *     MACAddress dest;						//	final destination used when routing fragments
 *     MACAddress orig;						//	originator of the fragment used when merging the packet
 *     uint16_t seqno;						//	sequence identification
 *     uint16_t total_size;					//	size of the merged packet
 * }
 * </pre>
 */
class INET_API batadv_frag_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    MACAddress dest;
    MACAddress orig;
    uint16_t seqno;
    uint16_t total_size;

  private:
    void copy(const batadv_frag_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_frag_packet&);

  public:
    batadv_frag_packet(const char *name=nullptr);
    batadv_frag_packet(const batadv_frag_packet& other);
    virtual ~batadv_frag_packet();
    batadv_frag_packet& operator=(const batadv_frag_packet& other);
    virtual batadv_frag_packet *dup() const override {return new batadv_frag_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual MACAddress& getDest();
    virtual const MACAddress& getDest() const {return const_cast<batadv_frag_packet*>(this)->getDest();}
    virtual void setDest(const MACAddress& dest);
    virtual MACAddress& getOrig();
    virtual const MACAddress& getOrig() const {return const_cast<batadv_frag_packet*>(this)->getOrig();}
    virtual void setOrig(const MACAddress& orig);
    virtual uint16_t getSeqno() const;
    virtual void setSeqno(uint16_t seqno);
    virtual uint16_t getTotal_size() const;
    virtual void setTotal_size(uint16_t total_size);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_frag_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_frag_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:373</tt> by nedtool.
 * <pre>
 * // Represents broadcast packet for network payload
 * class batadv_bcast_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_BCAST;			//	batman-adv packet type, part of the general header
 *     batadv_version = BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
 *     uint8_t ttl;						//	time to live for this packet, part of the genereal header
 *     uint8_t reserved;					//	reserved byte for alignment
 *     uint32_t seqno;						//	sequence identification
 *     MACAddress orig;						//	originator of the broadcast packet
 *     byteLength = BATADV_BCAST_HLEN;
 * 	//	"4 bytes boundary + 2 bytes" long to make the payload after the following ethernet header again 4 bytes boundary aligned
 * }
 * </pre>
 */
class INET_API batadv_bcast_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    uint8_t reserved;
    uint32_t seqno;
    MACAddress orig;

  private:
    void copy(const batadv_bcast_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_bcast_packet&);

  public:
    batadv_bcast_packet(const char *name=nullptr);
    batadv_bcast_packet(const batadv_bcast_packet& other);
    virtual ~batadv_bcast_packet();
    batadv_bcast_packet& operator=(const batadv_bcast_packet& other);
    virtual batadv_bcast_packet *dup() const override {return new batadv_bcast_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);
    virtual uint32_t getSeqno() const;
    virtual void setSeqno(uint32_t seqno);
    virtual MACAddress& getOrig();
    virtual const MACAddress& getOrig() const {return const_cast<batadv_bcast_packet*>(this)->getOrig();}
    virtual void setOrig(const MACAddress& orig);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_bcast_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_bcast_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:385</tt> by nedtool.
 * <pre>
 * // Represents ICMP packet
 * class batadv_icmp_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_ICMP;
 *     batadv_version = BATADV_COMPAT_VERSION;
 *     uint8_t ttl;
 *     uint8_t msg_type; // see ICMP message types above
 *     MACAddress dst;
 *     MACAddress orig;
 *     uint8_t uid;
 *     uint8_t reserved;
 *     uint32_t seqno;
 * }
 * </pre>
 */
class INET_API batadv_icmp_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    uint8_t msg_type;
    MACAddress dst;
    MACAddress orig;
    uint8_t uid;
    uint8_t reserved;
    uint32_t seqno;

  private:
    void copy(const batadv_icmp_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_icmp_packet&);

  public:
    batadv_icmp_packet(const char *name=nullptr);
    batadv_icmp_packet(const batadv_icmp_packet& other);
    virtual ~batadv_icmp_packet();
    batadv_icmp_packet& operator=(const batadv_icmp_packet& other);
    virtual batadv_icmp_packet *dup() const override {return new batadv_icmp_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual uint8_t getMsg_type() const;
    virtual void setMsg_type(uint8_t msg_type);
    virtual MACAddress& getDst();
    virtual const MACAddress& getDst() const {return const_cast<batadv_icmp_packet*>(this)->getDst();}
    virtual void setDst(const MACAddress& dst);
    virtual MACAddress& getOrig();
    virtual const MACAddress& getOrig() const {return const_cast<batadv_icmp_packet*>(this)->getOrig();}
    virtual void setOrig(const MACAddress& orig);
    virtual uint8_t getUid() const;
    virtual void setUid(uint8_t uid);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);
    virtual uint32_t getSeqno() const;
    virtual void setSeqno(uint32_t seqno);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_icmp_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_icmp_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:398</tt> by nedtool.
 * <pre>
 * // Represents ICMP TP Meter packet
 * class batadv_icmp_tp_packet extends batadv_icmp_packet
 * {
 *     uint8_t subtype;
 *     uint8_t session[2];
 *     simtime_t timestamp;//time when the packet has been sent. This value is filled in a
 * 						//TP_MSG and echoed back in the next TP_ACK so that the sender can compute the
 *  						//RTT (Round Trip Time). Since it is read only by the host which wrote it, 
 *  						//there is no need to store it using network order
 * }
 * </pre>
 */
class INET_API batadv_icmp_tp_packet : public ::inet::batadv_icmp_packet
{
  protected:
    uint8_t subtype;
    uint8_t session[2];
    ::omnetpp::simtime_t timestamp;

  private:
    void copy(const batadv_icmp_tp_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_icmp_tp_packet&);

  public:
    batadv_icmp_tp_packet(const char *name=nullptr);
    batadv_icmp_tp_packet(const batadv_icmp_tp_packet& other);
    virtual ~batadv_icmp_tp_packet();
    batadv_icmp_tp_packet& operator=(const batadv_icmp_tp_packet& other);
    virtual batadv_icmp_tp_packet *dup() const override {return new batadv_icmp_tp_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getSubtype() const;
    virtual void setSubtype(uint8_t subtype);
    virtual unsigned int getSessionArraySize() const;
    virtual uint8_t getSession(unsigned int k) const;
    virtual void setSession(unsigned int k, uint8_t session);
    virtual ::omnetpp::simtime_t getTimestamp() const;
    virtual void setTimestamp(::omnetpp::simtime_t timestamp);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_icmp_tp_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_icmp_tp_packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:408</tt> by nedtool.
 * <pre>
 * // ICMP RouteRecord packet
 * class batadv_icmp_packet_rr extends batadv_icmp_packet
 * {
 *     uint8_t rr_cur;
 *     MACAddress rr[BATADV_RR_LEN]; //route record array
 * }
 * 
 * ////Represents network coded packet
 * //class batadv_coded_packet extends BATMANV_ControlPackets {
 * //	batadv_packettype	=	BATADV_CODED;			//	batman-adv packet type, part of the general header
 * //	batadv_version		=	BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
 * //	uint8_t		 		ttl;						//	time to live for this packet, part of the genereal header
 * //	uint8_t		 		first_ttvn;					//	tt-version number of first included packet
 * //	//MACAddress first_dest; - saved in mac header destination
 * //	MACAddress			first_source;				//	original source of first included packet
 * // 	MACAddress 			first_orig_dest;			//	original destinal of first included packet
 * //	uint32_t	 		first_crc;					//	checksum of first included packet
 * //	uint8_t		 		second_ttl;					//	ttl of second packet
 * // 	uint8_t		 		second_ttvn;				//	tt version number of second included packet
 * //	MACAddress	 		second_dest;				//	second receiver of this coded packet
 * //	MACAddress	 		second_source;				//	original source of second included packet
 * //	MACAddress	 		second_orig_dest;			//	original destination of second included packet
 * //	uint32_t	 		second_crc;					//	checksum of second included packet
 * //	uint16_t	 		coded_len;					//	length of network coded part of the payload
 * //	byteLength			= BATADV_CODED_HLEN;
 * //};
 * </pre>
 */
class INET_API batadv_icmp_packet_rr : public ::inet::batadv_icmp_packet
{
  protected:
    uint8_t rr_cur;
    MACAddress rr[BATADV_RR_LEN];

  private:
    void copy(const batadv_icmp_packet_rr& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_icmp_packet_rr&);

  public:
    batadv_icmp_packet_rr(const char *name=nullptr);
    batadv_icmp_packet_rr(const batadv_icmp_packet_rr& other);
    virtual ~batadv_icmp_packet_rr();
    batadv_icmp_packet_rr& operator=(const batadv_icmp_packet_rr& other);
    virtual batadv_icmp_packet_rr *dup() const override {return new batadv_icmp_packet_rr(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getRr_cur() const;
    virtual void setRr_cur(uint8_t rr_cur);
    virtual unsigned int getRrArraySize() const;
    virtual MACAddress& getRr(unsigned int k);
    virtual const MACAddress& getRr(unsigned int k) const {return const_cast<batadv_icmp_packet_rr*>(this)->getRr(k);}
    virtual void setRr(unsigned int k, const MACAddress& rr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_icmp_packet_rr& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_icmp_packet_rr& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/Batman5/controlpackages/BATMANV_ControlPackets.msg:434</tt> by nedtool.
 * <pre>
 * // Represents generic unicast packet with tvlv payload
 * class batadv_unicast_tvlv_packet extends BATMANV_ControlPackets
 * {
 *     batadv_packettype = BATADV_UNICAST_TVLV;	//	batman-adv packet type, part of the general header
 *     batadv_version = BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
 *     uint8_t ttl;						//	time to live for this packet, part of the genereal header
 *     uint8_t reserved;					//	reserved field (for packet alignment)
 *     MACAddress dst;						//	address of the destination
 *     MACAddress src;						//	address of the source
 *     uint16_t tvlv_len;					//	length of tvlv data following the unicast tvlv header
 *     uint16_t align;						//	2 bytes to align the header to a 4 byte boundary
 * }
 * </pre>
 */
class INET_API batadv_unicast_tvlv_packet : public ::inet::BATMANV_ControlPackets
{
  protected:
    uint8_t ttl;
    uint8_t reserved;
    MACAddress dst;
    MACAddress src;
    uint16_t tvlv_len;
    uint16_t align;

  private:
    void copy(const batadv_unicast_tvlv_packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const batadv_unicast_tvlv_packet&);

  public:
    batadv_unicast_tvlv_packet(const char *name=nullptr);
    batadv_unicast_tvlv_packet(const batadv_unicast_tvlv_packet& other);
    virtual ~batadv_unicast_tvlv_packet();
    batadv_unicast_tvlv_packet& operator=(const batadv_unicast_tvlv_packet& other);
    virtual batadv_unicast_tvlv_packet *dup() const override {return new batadv_unicast_tvlv_packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getTtl() const;
    virtual void setTtl(uint8_t ttl);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);
    virtual MACAddress& getDst();
    virtual const MACAddress& getDst() const {return const_cast<batadv_unicast_tvlv_packet*>(this)->getDst();}
    virtual void setDst(const MACAddress& dst);
    virtual MACAddress& getSrc();
    virtual const MACAddress& getSrc() const {return const_cast<batadv_unicast_tvlv_packet*>(this)->getSrc();}
    virtual void setSrc(const MACAddress& src);
    virtual uint16_t getTvlv_len() const;
    virtual void setTvlv_len(uint16_t tvlv_len);
    virtual uint16_t getAlign() const;
    virtual void setAlign(uint16_t align);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const batadv_unicast_tvlv_packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, batadv_unicast_tvlv_packet& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_BATMANV_CONTROLPACKETS_M_H

