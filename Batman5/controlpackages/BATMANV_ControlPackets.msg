//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

//	Implementation of B.A.T.M.A.N. V in OMNeT++
// 	Data integrated from uapi/linux/batadv_packet.h

class noncobject tt_changeList;

cplusplus {{
#include "inet/common/INETDefs.h"
#include "inet/common/geometry/common/Coord.h"
#include "inet/linklayer/common/MACAddress.h"
#include "inet/Batman5/Batman5Files/batadv_definitions.h"

#define BIT0  0000000000000001
#define BIT1  0000000000000010
#define BIT2  0000000000000100
#define BIT3  0000000000001000
#define BIT4  0000000000010000
#define BIT5  0000000000100000
#define BIT6  0000000001000000
#define BIT7  0000000010000000
#define BIT8  0000000100000000
#define BIT9  0000001000000000
#define BIT10 0000010000000000
#define BIT11 0000100000000000
#define BIT12 0001000000000000
#define BIT13 0010000000000000
#define BIT14 0100000000000000
#define BIT15 1000000000000000

#define BATADV_COMPAT_VERSION 15
#define BATADV_TT_DATA_TYPE_MASK 0x0F
#define BATADV_OGM_HLEN 19
#define BATADV_OGM2_HLEN 20
#define BATADV_ELP_HLEN 16
#define BATADV_RR_LEN 16

#define BATADV_UNICAST_HLEN 10
#define BATADV_UNICAST_4ADDR_HLEN 18
#define BATADV_BCAST_HLEN 14
#define BATADV_CODED_HLEN 46


}}

namespace inet;

class noncobject MACAddress;


enum batadv_packettype {
    // 0x00 - 0x3f: local packets or special rules for handling */
    		BATADV_IV_OGM           = 0x00;
    		BATADV_BCAST            = 0x01;
    		BATADV_CODED            = 0x02;
    		BATADV_ELP              = 0x03;	// BATMAN V
    		BATADV_OGM2             = 0x04;	// BATMAN V
    // 0x40 - 0x7f: unicast */
	// 		BATADV_UNICAST_MIN     	  0x40;
			BATADV_UNICAST          = 0x40;
			BATADV_UNICAST_FRAG     = 0x41;
			BATADV_UNICAST_4ADDR    = 0x42;
			BATADV_ICMP             = 0x43;	// not implemented here
			BATADV_UNICAST_TVLV     = 0x44;
	// 		BATADV_UNICAST_MAX   	  0x7f;
	// 0x80 - 0xff: reserved */
   };

enum batadv_version {
 	BATMAN_IV		= 4;
 	BATMAN_V		= 5;  
}

//	enum batadv_subtype - packet subtype for unicast4addr
enum batadv_subtype {
	BATADV_P_DATA                   = 0x01;	//	user payload
	BATADV_P_DAT_DHT_GET            = 0x02;	//	DHT request message
	BATADV_P_DAT_DHT_PUT            = 0x03;	//	DHT store message
	BATADV_P_DAT_CACHE_REPLY        = 0x04;	//	ARP reply generated by DAT
};

//	enum batadv_iv_flags - flags used in B.A.T.M.A.N. IV OGM packets
enum batadv_iv_flags {
    BATADV_NOT_BEST_NEXT_HOP   		= BIT0;	//	flag is set when ogm packet is forwarded and was previously received from someone else than the best neighbor
    BATADV_PRIMARIES_FIRST_HOP 		= BIT1;	//	flag unused
    BATADV_DIRECTLINK          		= BIT2;	//	flag is for the first hop or if rebroadcasted from a one hop neighbor on the interface where it was originally received
};

//	enum batadv_icmp_packettype - ICMP message types
enum batadv_icmp_messagetype {
	BATADV_ECHO_REPLY             	 = 0;		//	success reply to BATADV_ECHO_REQUEST
	BATADV_DESTINATION_UNREACHABLE	 = 3;		//	failure when route to destination not found
	BATADV_ECHO_REQUEST           	 = 8;		//	request BATADV_ECHO_REPLY from destination
	BATADV_TTL_EXCEEDED           	 = 11;	//	error after BATADV_ECHO_REQUEST traversed too many hops
	BATADV_PARAMETER_PROBLEM      	 = 12;	//	return code for malformed messages
	BATADV_TP                     	 = 15;	//	throughput meter packet
};


// enum batadv_icmp_tp_subtype - ICMP TP Meter packet subtypes
enum batadv_icmp_tp_subtype {
	BATADV_TP_MSG	= 0;	// @BATADV_TP_MSG: Msg from sender to receiver
	BATADV_TP_ACK   = 1;	// @BATADV_TP_ACK: acknowledgment from receiver to sender
};

//	batadv_mcast_flags - flags for multicast capabilities and settings
enum batadv_mcast_flags {
	BATADV_MCAST_WANT_ALL_UNSNOOPABLES	= BIT0; 	//	we want all packets destined for 224.0.0.0/24 or ff02::1
	BATADV_MCAST_WANT_ALL_IPV4        	= BIT1; 	//	we want all IPv4 multicast packets
	BATADV_MCAST_WANT_ALL_IPV6        	= BIT2;		//	we want all IPv6 multicast packets
};

//	enum batadv_tt_data_flags - flags for tt data tvlv
enum batadv_tt_data_flags {
	BATADV_TT_OGM_DIFF   	= BIT0;		//	TT diff propagated through OGM
	BATADV_TT_REQUEST    	= BIT1;		//	TT request message
	BATADV_TT_RESPONSE   	= BIT2;		//	TT response message
	BATADV_TT_FULL_TABLE 	= BIT4;		//	contains full table to replace existing table
};

//	enum batadv_vlan_flags - flags for the four MSB of any vlan ID field
enum batadv_vlan_flags {
	BATADV_VLAN_HAS_TAG		= BIT14;	//	whether the field contains a valid vlan tag or not
};

//	enum batadv_bla_claimframe - claim frame types for the bridge loop avoidance
enum batadv_bla_claimframe {
	BATADV_CLAIM_TYPE_CLAIM         = 0x00;	//	claim of a client mac address
	BATADV_CLAIM_TYPE_UNCLAIM       = 0x01;	//	unclaim of a client mac address
	BATADV_CLAIM_TYPE_ANNOUNCE      = 0x02;	//	announcement of backbone with current crc
	BATADV_CLAIM_TYPE_REQUEST       = 0x03;	//	request of full claim table
	BATADV_CLAIM_TYPE_LOOPDETECT    = 0x04;	//	mesh-traversing loop detect packet
};

//	enum batadv_tvlv_type - tvlv type definitions
enum batadv_tvlv_type {
	BATADV_TVLV_GW          = 0x01;	//	gateway tvlv
	BATADV_TVLV_DAT         = 0x02;	//	distributed arp table tvlv
	BATADV_TVLV_NC          = 0x03;	//	network coding tvlv
	BATADV_TVLV_TT          = 0x04;	//	translation table tvlv
	BATADV_TVLV_ROAM        = 0x05;	//	roaming advertisement tvlv
	BATADV_TVLV_MCAST       = 0x06;	//	multicast capability tvlv
};

// Base packet for BATMAN V Control Packets
packet BATMANV_ControlPackets {
	uint8_t batadv_packettype;
	uint8_t batadv_version;
}


// Base packet for BATMAN V TVLV Packets
packet BATMANV_TVLVPackets {
 	uint8_t  batadv_tvlv_type;
 	uint8_t  version;
 	uint16_t length;
// 	byteLength = 0; // with that ogmv2s without tvlv container do not get bigger
}


//gateway data propagated through gw tvlv container
packet batadv_tvlv_gateway_data extends BATMANV_TVLVPackets {
    batadv_tvlv_type = BATADV_TVLV_GW;
 	version = BATADV_COMPAT_VERSION;
 	length = 8;
    uint32_t bandwidth_down;
	uint32_t bandwidth_up;
	byteLength = 12;
}

// DAT: boolean telling that this node caches ARP requests / replies for the mesh
packet batadv_tvlv_dat extends BATMANV_TVLVPackets {
    batadv_tvlv_type = BATADV_TVLV_DAT;
 	version = BATADV_COMPAT_VERSION;
 	length = 0;
 	byteLength = 4;
}

// Network Coding: boolean telling that this node knows how to decode nc-packets
packet batadv_tvlv_nc extends BATMANV_TVLVPackets {
    batadv_tvlv_type = BATADV_TVLV_NC;
 	version = BATADV_COMPAT_VERSION;
 	length = 0;
 	byteLength = 4;
}

//tt data propagated through the tt tvlv container
packet batadv_tvlv_tt_data extends BATMANV_TVLVPackets {
    batadv_tvlv_type = BATADV_TVLV_TT;
 	version = BATADV_COMPAT_VERSION;
 	length = 4;
	uint8_t tt_flags;
	uint8_t ttvn;
	uint16_t num_vlan = 0;
}

packet batadv_tvlv_tt_vlan extends batadv_tvlv_tt_data {
    num_vlan = 1;
 	int32_t crc32;
 	int16_t vid_vlan;
 	int16_t reserved_vlan;
 	byteLength = 16;
}

// 
packet batadv_tvlv_tt_change extends batadv_tvlv_tt_data {
    int8_t flags_change;// enum batadv_tt_client_flags - TT client specific flags
    int16_t reserved16_change;
    int8_t reserved8_change;
    MACAddress addr;
    int16_t vid_change;
    byteLength = 20;
}

packet batadv_tvlv_tt_vlan_change extends batadv_tvlv_tt_data {
    num_vlan = 1;
 	int32_t crc32;
 	int16_t vid_vlan;
 	int16_t reserved_vlan;
 	
 	int8_t flags;// enum batadv_tt_client_flags - TT client specific flags
    int16_t reserved16_change;
    int8_t reserved8_change;
    MACAddress addr;
    int16_t vid_change;
    byteLength = 28;
}

// Inform the old AP about the new location of the non-mesh client
packet batadv_tvlv_roam_adv extends BATMANV_TVLVPackets {
    batadv_tvlv_type = BATADV_TVLV_ROAM;
 	version = BATADV_COMPAT_VERSION;
 	length = 8;
	MACAddress client;
	uint16_t vid;
	byteLength = 12;
}

packet batadv_tvlv_mcast extends BATMANV_TVLVPackets {
    batadv_tvlv_type = BATADV_TVLV_MCAST;
 	version = BATADV_COMPAT_VERSION;
 	length = 4;
 	int8_t flags;
 	int16_t reserved16;
    int8_t reserved8;
 	byteLength = 8;
}

//
//	*****************************	Packet-Definitions	*****************************
//


// Represents Echo Location Protocol packets
class batadv_elp_packet extends BATMANV_ControlPackets {
    batadv_packettype 	= BATADV_ELP;			//	batman-adv packet type, part of the general header ELP-Packet = 0x03
    batadv_version 		= BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the genereal header
    MACAddress 			orig;					//	originator mac address
    uint32_t 			seqno;					//	sequence number
    uint32_t			elp_interval;			//	currently used ELP sending interval in ms
    double 				x;						// 	only used in position based metrics, packet-size will be adapted if used
    double				y;						// 	only used in position based metrics, packet-size will be adapted if used
    double 				z;						// 	only used in position based metrics, packet-size will be adapted if used
    byteLength			= sizeof(batadv_packettype) + sizeof(batadv_version) + orig.getAddressSize() + sizeof(seqno) + sizeof(elp_interval); 
    						//1+1+6+4+4;
}

class batadv_elpProbe_packet extends batadv_elp_packet {
    batadv_elp_packet	elp_packet;
    byteLength 			= BATADV_ELP_MIN_PROBE_SIZE;
}

// Represents Originator Message packets
class batadv_iv_ogm_packet extends BATMANV_ControlPackets {
	batadv_packettype	= BATADV_IV_OGM;	//	batman-adv packet type, part of the general header
	batadv_version		= BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the genereal header
	uint8_t   			ttl;				//	time to live for this packet, part of the genereal header
	uint8_t   			flags;				//	contains routing relevant flags - see enum batadv_iv_flags
    uint32_t 			seqno;				//	sequence identification
   	MACAddress	 		orig;				//	address of the source node
   	MACAddress  		prev_sender;		//	address of the previous sender
   	uint8_t	  			reserved;			//	reserved byte for alignment
    uint8_t  			tq;					//	transmission quality, between 0...255
    uint16_t 			tvlv_len;			//	length of tvlv data following the ogm header
    };

// Represents Originator Message Version 2 packets
class batadv_ogm2_packet extends BATMANV_ControlPackets {
    batadv_packettype 	= BATADV_OGM2;			//	batman-adv packet type, part of the general header, ogmv2-packet = 0x04
    batadv_version 		= BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the general header
    uint8_t			   	ttl;					//	time to live for this packet, part of the general header
    uint8_t			   	flags;					//	reseved for routing relevant flags - currently always 0
    uint32_t	 		seqno;					//	sequence number
    MACAddress   		orig;					//	originator mac address
    uint16_t			tvlv_len;				//	length of the appended tvlv buffer (in bytes)
    uint32_t	 		metric;					//	the currently flooded path throughput
    MACAddress 			prev_sender;				//  For using NetworkCoding in BATMANV
//    BATMANV_TVLVPackets tvlv_packet;
    byteLength = 20; // without tvlv;
}

//	All packet headers in front of an ethernet header have to be completely
//	divisible by 2 but not by 4 to make the payload after the ethernet
//	header again 4 bytes boundary aligned.
//	
//	A packing of 2 is necessary to avoid extra padding at the end of the struct
//	caused by a structure member which is larger than two bytes. Otherwise
//	the structure would not fulfill the previously mentioned rule to avoid the
//	misalignment of the payload after the ethernet header. It may also lead to
//	leakage of information when the padding it not initialized before sending.

// Represents unicast packet for network payload
class batadv_unicast_packet extends BATMANV_ControlPackets {
	batadv_packettype	= BATADV_UNICAST;	//	batman-adv packet type, part of the general header
	batadv_version		= BATADV_COMPAT_VERSION;//	batman-adv protocol version, part of the genereal header
	uint8_t		 		ttl;				//	time to live for this packet, part of the genereal header
	uint8_t		 		ttvn; 				//	destination translation table version number
	MACAddress			dest;				//	originator destination of the unicast packet
	MACAddress			src;				//	address of the source
	MACAddress			h_source;			//  used for network coding with BATMAN V
	MACAddress 			h_dest;				//  used for network coding with BATMAN V
	bool				decoded;			//  used for network coding with BATMAN V
	uint64_t			packet_id;			//  used for network coding with BATMAN V
	byteLength			= BATADV_UNICAST_HLEN;
	//	"4 bytes boundary + 2 bytes" long to make the payload after the following ethernet header again 4 bytes boundary aligned
};

// Represents extended unicast packet
class batadv_unicast_4addr_packet extends batadv_unicast_packet {
	batadv_packettype	= BATADV_UNICAST_4ADDR;	//	batman-adv packet type, part of the general header	
	uint8_t		 	subtype;	//	packet subtype
	uint8_t			reserved;	//	reserved byte for alignment
	byteLength		= BATADV_UNICAST_4ADDR_HLEN;
	//	"4 bytes boundary + 2 bytes" long to make the payload after the following ethernet header again 4 bytes boundary aligned
};

// Represents fragmented packet
class batadv_frag_packet extends BATMANV_ControlPackets {
	batadv_packettype	=	BATADV_UNICAST_FRAG;	//	batman-adv packet type, part of the general header
	batadv_version		=	BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
	uint8_t		 		ttl;						//	time to live for this packet, part of the genereal header
	// #if defined(__BIG_ENDIAN_BITFIELD)
	//uint8_t   	no:4;						//	fragment number within this sequence
	//uint8_t   	priority:3;					//	priority of frame, from ToS IP precedence or 802.1p
	//uint8_t   	reserved:1;					//	reserved byte for alignment
	// #elif defined(__LITTLE_ENDIAN_BITFIELD)
	//uint8_t   	reserved:1;
	//uint8_t  	priority:3;
	//uint8_t   	no:4;
	// #else
	// #error "unknown bitfield endianness"
	// #endif
	MACAddress  		dest;						//	final destination used when routing fragments
	MACAddress			orig;						//	originator of the fragment used when merging the packet
	uint16_t			seqno;						//	sequence identification
	uint16_t	 		total_size;					//	size of the merged packet
};

// Represents broadcast packet for network payload
class batadv_bcast_packet extends BATMANV_ControlPackets{
	batadv_packettype	=	BATADV_BCAST;			//	batman-adv packet type, part of the general header
	batadv_version		=	BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
	uint8_t				ttl;						//	time to live for this packet, part of the genereal header
	uint8_t				reserved;					//	reserved byte for alignment
	uint32_t	 		seqno;						//	sequence identification
	MACAddress			orig;						//	originator of the broadcast packet
	byteLength			= BATADV_BCAST_HLEN;
	//	"4 bytes boundary + 2 bytes" long to make the payload after the following ethernet header again 4 bytes boundary aligned
};

// Represents ICMP packet
class batadv_icmp_packet extends BATMANV_ControlPackets{
	batadv_packettype	=	BATADV_ICMP;
	batadv_version		=	BATADV_COMPAT_VERSION;
	uint8_t			   		ttl;
	uint8_t  				msg_type; // see ICMP message types above
	MACAddress   			dst;
	MACAddress   			orig;
	uint8_t   				uid;
	uint8_t   				reserved;
	uint32_t			 	seqno;
};

// Represents ICMP TP Meter packet
class batadv_icmp_tp_packet extends batadv_icmp_packet{ 
	uint8_t					subtype;
	uint8_t   				session[2];
	simtime_t timestamp;//time when the packet has been sent. This value is filled in a
						//TP_MSG and echoed back in the next TP_ACK so that the sender can compute the
 						//RTT (Round Trip Time). Since it is read only by the host which wrote it, 
 						//there is no need to store it using network order
};

// ICMP RouteRecord packet
class batadv_icmp_packet_rr extends batadv_icmp_packet{
	uint8_t   				rr_cur;
	MACAddress   			rr[BATADV_RR_LEN]; //route record array
};

////Represents network coded packet
//class batadv_coded_packet extends BATMANV_ControlPackets {
//	batadv_packettype	=	BATADV_CODED;			//	batman-adv packet type, part of the general header
//	batadv_version		=	BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
//	uint8_t		 		ttl;						//	time to live for this packet, part of the genereal header
//	uint8_t		 		first_ttvn;					//	tt-version number of first included packet
//	//MACAddress first_dest; - saved in mac header destination
//	MACAddress			first_source;				//	original source of first included packet
// 	MACAddress 			first_orig_dest;			//	original destinal of first included packet
//	uint32_t	 		first_crc;					//	checksum of first included packet
//	uint8_t		 		second_ttl;					//	ttl of second packet
// 	uint8_t		 		second_ttvn;				//	tt version number of second included packet
//	MACAddress	 		second_dest;				//	second receiver of this coded packet
//	MACAddress	 		second_source;				//	original source of second included packet
//	MACAddress	 		second_orig_dest;			//	original destination of second included packet
//	uint32_t	 		second_crc;					//	checksum of second included packet
//	uint16_t	 		coded_len;					//	length of network coded part of the payload
//	byteLength			= BATADV_CODED_HLEN;
//};

// Represents generic unicast packet with tvlv payload
class batadv_unicast_tvlv_packet extends BATMANV_ControlPackets{
	batadv_packettype	=	BATADV_UNICAST_TVLV;	//	batman-adv packet type, part of the general header
	batadv_version		=	BATADV_COMPAT_VERSION;	//	batman-adv protocol version, part of the genereal header
	uint8_t				ttl;						//	time to live for this packet, part of the genereal header
	uint8_t				reserved;					//	reserved field (for packet alignment)
	MACAddress			dst;						//	address of the destination
	MACAddress			src;						//	address of the source
	uint16_t			tvlv_len;					//	length of tvlv data following the unicast tvlv header
	uint16_t	 		align;						//	2 bytes to align the header to a 4 byte boundary
};


